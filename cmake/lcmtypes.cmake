# Macros for automatically compiling LCM types into C, Java, and Python
# libraries.
#
# The primary macro is:
#     lcmtypes_build([C_AGGREGATE_HEADER header_fname] 
#                    [C_LIBNAME lib_name]
#                    [JAVA_DEST_DIR dir_name]
#                    [PY_DEST_DIR dir_name]
#                    )
# 
# It expects that the directory ${PROJECT_SOURCE_DIR}/lcmtypes contains all
# the LCM types used by the system.  The macro generates C, Java, and Python
# bindings.  See the C, Java, and Python sections below for information on
# language specific options and generated results.
#
# After invoking this macro, the following variables will be set:
#
#   LCMTYPES_LIBS
#   LCMTYPES_JAR
#
# 
# C
# ==
# 
# C bindings will be placed in ${PROJECT_SOURCE_DIR}/lcmtypes/c.  
#
# The autogenerated C bindings also get compiled to a static and shared
# library.  The library prefix will be stored in LCMTYPES_LIBS on output.
# This prefix can be manually set using the C_LIBNAME option.
# 
# Additionally, a header file will be generated that automatically includes
# all of the other automatically generated header files.  The name of this
# header file defaults to a cleaned-up version of "${PROJECT_NAME}.h" 
# (non-alphanumeric characters replaced with underscores), but can
# be manually set using the C_AGGREGATE_HEADER option.
#
# C++
# ==
# 
# C++ bindings will be placed in ${PROJECT_SOURCE_DIR}/lcmtypes/cpp.
#
# The autogenerated CPP bindings are header only, so no library is created.
# 
# A header file will be generated that automatically includes
# all of the other automatically generated header files.  The name of this
# header file defaults to a cleaned-up version of "${PROJECT_NAME}.hpp" 
# (non-alphanumeric characters replaced with underscores), but can
# be manually set using the CPP_AGGREGATE_HEADER option.
#
#
# Java
# ====
#
# If Java is available, then Java bindings are be generated and placed in 
#    ${PROJECT_SOURCE_DIR}/lcmtypes/java
#
# This directory can be changed using the JAVA_DEST_DIR option.
# 
# Additionally, targets are added to automatically compile the .java files to a
# .jar file. The location of this jar file is stored in LCMTYPES_JAR
#
# and the .jar file will be installed to 
#   ${CMAKE_INSTALL_PREFIX}/lib
#
#
# Python
# ======
#
# If Python is enabled, then python bindings will be generated and placed in 
#    ${PROJECT_SOURCE_DIR}/lcmtypes/python
# 
# This directory can be changed by setting the PY_DEST_DIR option.
#
# Additionally, the .py files will be installed to 
#   ${CMAKE_INSTALL_PREFIX}/lib/python{X.Y}/dist-packages
#   
# where {X.Y} refers to the python version used to build the .py files.
#
# ----
# File: lcmtypes.cmake

find_package(PkgConfig REQUIRED)
pkg_check_modules(LCM lcm)

if (LCM_FOUND)
    #find lcm-gen (it may be in the install path)
    find_program(LCM_GEN_EXECUTABLE NAMES lcm-gen
        HINTS ${EXECUTABLE_OUTPUT_PATH} ${EXECUTABLE_INSTALL_PATH})

    if (NOT LCM_GEN_EXECUTABLE)
        message(STATUS "${EXECUTABLE_OUTPUT_PATH} ${EXECUTABLE_INSTALL_PATH}")
        message(STATUS "lcm-gen not found")
        unset(LCM_FOUND)
    endif()
endif()

# get a list of all LCM types
macro(lcmtypes_get_types msgvar)
    file(GLOB_RECURSE ${msgvar} "${PROJECT_SOURCE_DIR}/lcmtypes/*.lcm")
endmacro()

function(add_clean_dir clean_dir)
    get_directory_property(acfiles ADDITIONAL_MAKE_CLEAN_FILES)
    list(APPEND acfiles ${clean_dir})
    set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${acfiles}")
endfunction()

function(lcmtypes_build_c)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    string(REGEX REPLACE "[^a-zA-Z0-9]" "_" __sanitized_project_name "${PROJECT_NAME}")

    # library name
    set(libname "lcmtypes_${PROJECT_NAME}")

    # header file that includes all other generated header files
    set(agg_h_bname "${__sanitized_project_name}.h")

    # generate C bindings for LCM types
    set(_lcmtypes_c_dir ${CMAKE_BINARY_DIR}/lcmgen/c)

    # run lcm-gen now
    execute_process(COMMAND mkdir -p ${_lcmtypes_c_dir})
    execute_process(COMMAND lcm-gen --lazy -c --c-cpath ${_lcmtypes_c_dir} --c-hpath ${_lcmtypes_c_dir} ${_lcmtypes})

    # run lcm-gen at compile time
    add_custom_target(lcmgen_c ALL 
        COMMAND sh -c '[ -d ${_lcmtypes_c_dir} ] || mkdir -p ${_lcmtypes_c_dir}'
        COMMAND sh -c '${LCM_GEN_EXECUTABLE} --lazy -c ${_lcmtypes} --c-cpath ${_lcmtypes_c_dir} --c-hpath ${_lcmtypes_c_dir}')

    # get a list of all generated .c and .h files
    file(GLOB _lcmtypes_c_files ${_lcmtypes_c_dir}/*.c)
    file(GLOB _lcmtypes_h_files ${_lcmtypes_c_dir}/*.h)

    # include LCM directories
    include_directories(SYSTEM ${LCM_INCLUDE_DIRS} ${LIBBOT_INCLUDE_DIRS})

    # aggregate into a static library
    add_library(${libname} STATIC ${_lcmtypes_c_files})
    add_dependencies(${libname} lcmgen_c)

    # create a header file aggregating all of the autogenerated .h files
    set(__agg_h_fname "${_lcmtypes_c_dir}/${agg_h_bname}")
    file(WRITE ${__agg_h_fname}
        "#ifndef __lcmtypes_c_${__sanitized_project_name}_h__\n"
        "#define __lcmtypes_c_${__sanitized_project_name}_h__\n\n")
    foreach(h_file ${_lcmtypes_h_files})
        file(RELATIVE_PATH __tmp_path ${_lcmtypes_c_dir} ${h_file})
        file(APPEND ${__agg_h_fname} "#include \"${__tmp_path}\"\n")
    endforeach()
    file(APPEND ${__agg_h_fname} "\n#endif\n")
    list(APPEND _lcmtypes_h_files ${__agg_h_fname})
    unset(__sanitized_project_name)
    unset(__agg_h_fname)

    # make header files and libraries public
    pods_install_libraries(${libname})
    pods_install_headers(${_lcmtypes_h_files} DESTINATION lcmtypes)

    add_clean_dir("${_lcmtypes_c_dir}")
endfunction()

function(lcmtypes_build_cpp)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    string(REGEX REPLACE "[^a-zA-Z0-9]" "_" __sanitized_project_name "${PROJECT_NAME}")

    # header file that includes all other generated header files
    set(agg_hpp_bname "${__sanitized_project_name}.hpp")

    # generate CPP bindings for LCM types
    set(_lcmtypes_cpp_dir ${CMAKE_BINARY_DIR}/lcmgen/cpp)

    # run lcm-gen now
    execute_process(COMMAND mkdir -p ${_lcmtypes_cpp_dir})
    execute_process(COMMAND lcm-gen --lazy --cpp --cpp-hpath ${_lcmtypes_cpp_dir} ${_lcmtypes} --cpp-include ..)

    # run lcm-gen at compile time
    add_custom_target(lcmgen_cpp ALL 
        COMMAND sh -c '[ -d ${_lcmtypes_cpp_dir} ] || mkdir -p ${_lcmtypes_cpp_dir}'
        COMMAND sh -c '${LCM_GEN_EXECUTABLE} --lazy --cpp ${_lcmtypes} --cpp-hpath ${_lcmtypes_cpp_dir} --cpp-include ..')

    # get a list of all generated .hpp files
    file(GLOB_RECURSE _lcmtypes_hpp_files  ${_lcmtypes_cpp_dir}/*.hpp)
    
    include_directories(SYSTEM ${LCM_INCLUDE_DIRS})

    # create a header file aggregating all of the autogenerated .hpp files
    set(__agg_hpp_fname "${_lcmtypes_cpp_dir}/${agg_hpp_bname}")
    file(WRITE ${__agg_hpp_fname}
        "#ifndef __lcmtypes_cpp_${__sanitized_project_name}_hpp__\n"
        "#define __lcmtypes_cpp_${__sanitized_project_name}_hpp__\n\n")
    
    foreach(hpp_file ${_lcmtypes_hpp_files})
        file(RELATIVE_PATH __tmp_path ${_lcmtypes_cpp_dir} ${hpp_file})
        file(APPEND ${__agg_hpp_fname} "#include \"${__tmp_path}\"\n")
        get_filename_component(__tmp_dir ${__tmp_path} PATH)
        pods_install_headers(${hpp_file} DESTINATION lcmtypes/${__tmp_dir})
    endforeach()
    file(APPEND ${__agg_hpp_fname} "\n#endif\n")

    pods_install_headers(${__agg_hpp_fname} DESTINATION lcmtypes)
    add_clean_dir("${_lcmtypes_cpp_dir}")
    unset(__sanitized_project_name)
    unset(__agg_hpp_fname)
endfunction()

function(lcmtypes_build_java)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    # do we have Java?
    find_package(Java)
    if(JAVA_COMPILE STREQUAL JAVA_COMPILE-NOTFOUND OR
       JAVA_ARCHIVE STREQUAL JAVA_ARCHIVE-NOTFOUND)
        message(STATUS "Not building Java LCM type bindings (Can't find Java)")
        return()
    endif()

    # do we have LCM java bindings?  where is lcm.jar?
    execute_process(COMMAND pkg-config --variable=classpath lcm-java OUTPUT_VARIABLE LCM_JAR_FILE)
    if(NOT LCM_JAR_FILE)
        message(STATUS "Not building Java LCM type bindings (Can't find lcm.jar)")
        return()
    endif()
    string(STRIP ${LCM_JAR_FILE} LCM_JAR_FILE)
     
    set(LCMTYPES_JAR ${CMAKE_BINARY_DIR}/lib/lcmtypes_${PROJECT_NAME}.jar)

    # generate Java bindings for LCM types
    set(_lcmtypes_java_dir ${CMAKE_BINARY_DIR}/lcmgen/java)

    # run lcm-gen now
    execute_process(COMMAND mkdir -p ${_lcmtypes_java_dir})
    execute_process(COMMAND lcm-gen --lazy -j ${_lcmtypes} --jpath ${_lcmtypes_java_dir})

    # run lcm-gen at compile time
    add_custom_target(lcmgen_java ALL
        COMMAND sh -c '[ -d ${_lcmtypes_java_dir} ] || mkdir -p ${_lcmtypes_java_dir}'
        COMMAND sh -c '${LCM_GEN_EXECUTABLE} --lazy -j ${_lcmtypes} --jpath ${_lcmtypes_java_dir}')

    # get a list of all generated .java files
    file(GLOB_RECURSE _lcmtypes_java_files ${_lcmtypes_java_dir}/*.java)

    set(java_classpath ${_lcmtypes_java_dir}:${LCM_JAR_FILE})

    # search for lcmtypes_*.jar files in well-known places and add them to the
    # classpath
    foreach(pfx /usr /usr/local ${CMAKE_INSTALL_PREFIX})
        file(GLOB_RECURSE jarfiles ${pfx}/share/java/lcmtypes_*.jar)
        foreach(jarfile ${jarfiles})
            set(java_classpath ${java_classpath}:${jarfile})
            #message("found ${jarfile}")
        endforeach()
    endforeach()

    # convert the list of .java filenames to a list of .class filenames
    foreach(javafile ${_lcmtypes_java_files})
        string(REPLACE .java .class __tmp_class_fname ${javafile})
        list(APPEND _lcmtypes_class_files ${__tmp_class_fname})
        unset(__tmp_class_fname)
    endforeach()

    # add a rule to build the .class files from from the .java files
    add_custom_command(OUTPUT ${_lcmtypes_class_files}
        COMMAND ${JAVA_COMPILE} -source 6 -target 6 -cp ${java_classpath} ${_lcmtypes_java_files} 
        DEPENDS ${_lcmtypes_java_files} VERBATIM)

    # add a rule to build a .jar file from the .class files
    add_custom_command(OUTPUT lib/lcmtypes_${PROJECT_NAME}.jar
        COMMAND ${JAVA_ARCHIVE} cf ${LCMTYPES_JAR} -C ${_lcmtypes_java_dir} .
        DEPENDS ${_lcmtypes_class_files} VERBATIM)

    add_custom_target(lcmtypes_${PROJECT_NAME}_jar ALL
        DEPENDS ${LCMTYPES_JAR})

    add_dependencies(lcmtypes_${PROJECT_NAME}_jar
        lcmgen_java)

    #message(${LCMTYPES_JAR})
    install(FILES ${LCMTYPES_JAR}
        DESTINATION share/java)

    add_clean_dir(${_lcmtypes_java_dir})
endfunction()

function(lcmtypes_build_python)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    find_package(PythonInterp)
    if(NOT PYTHONINTERP_FOUND)
        message(STATUS "Not building Python LCM type bindings (Can't find Python)")
        return()
    endif()

    set(_lcmtypes_python_dir ${CMAKE_BINARY_DIR}/lcmgen/python)

    # generate Python bindings for LCM types
    execute_process(COMMAND mkdir -p ${_lcmtypes_python_dir})
    execute_process(COMMAND lcm-gen --lazy -p ${_lcmtypes} --ppath ${_lcmtypes_python_dir})

    # run lcm-gen at compile time
    add_custom_target(lcmgen_python ALL
        COMMAND sh -c 'lcm-gen --lazy -p ${_lcmtypes} --ppath ${_lcmtypes_python_dir}')

    pods_install_python_packages(${_lcmtypes_python_dir})
    add_clean_dir(${_lcmtypes_python_dir})
endfunction()

function(lcmtypes_build_lua)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    set(_lcmtypes_lua_dir ${CMAKE_BINARY_DIR}/lcmgen/lua)
    
    # configure time
    execute_process(COMMAND mkdir -p ${_lcmtypes_lua_dir})
    execute_process(COMMAND lcm-gen --lazy --lua ${_lcmtypes} --lpath ${_lcmtypes_lua_dir})
    
    # compile time
    add_custom_target(lcmgen_lua ALL
        COMMAND sh -c 'lcm-gen --lazy --lua ${_lcmtypes} --lpath ${_lcmtypes_lua_dir}')
    
    file(GLOB_RECURSE _lcmtypes_lua_files  ${_lcmtypes_lua_dir}/*.lua)
    
    install(FILES  ${_lcmtypes_lua_files} DESTINATION include/lcmtypes/lua)
    add_clean_dir(${_lcmtypes_lua_dir})
endfunction()


function (lcmtypes_build_csharp)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    set(_lcmtypes_csharp_dir ${CMAKE_BINARY_DIR}/lcmgen/csharp)
    
    # configure time
    execute_process(COMMAND mkdir -p ${_lcmtypes_csharp_dir})
    execute_process(COMMAND lcm-gen --lazy --csharp ${_lcmtypes} --csharp-path ${_lcmtypes_csharp_dir})
    
    # compile time
    add_custom_target(lcmgen_csharp ALL
        COMMAND sh -c 'lcm-gen --lazy --csharp ${_lcmtypes} --csharp-path ${_lcmtypes_csharp_dir}')
    
    file(GLOB_RECURSE _lcmtypes_csharp_files  ${_lcmtypes_csharp_dir}/*.cs)
    
    install(FILES  ${_lcmtypes_csharp_files} DESTINATION include/lcmtypes/csharp)
    add_clean_dir(${_lcmtypes_csharp_dir})
endfunction()

function(lcmtypes_install_types)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    install(FILES ${_lcmtypes} DESTINATION share/lcmtypes)
endfunction()

macro(lcmtypes_build)
    find_package(PkgConfig REQUIRED)
    pkg_check_modules(LCM REQUIRED lcm)
    
    #find lcm-gen (it may be in the install path)
    find_program(LCM_GEN_EXECUTABLE lcm-gen ${EXECUTABLE_OUTPUT_PATH} ${EXECUTABLE_INSTALL_PATH})
    if (NOT LCM_GEN_EXECUTABLE)
    	message(FATAL_ERROR "lcm-gen not found!\n")
    	return()
    endif()
    
    lcmtypes_build_c()
    lcmtypes_build_cpp()

    lcmtypes_build_java()
    lcmtypes_build_python()
    #lcmtypes_build_lua()
    #lcmtypes_build_csharp()

    lcmtypes_install_types()
endmacro()

if(LCM_FOUND)
    lcmtypes_build()
else()
    message(FATAL_ERROR "[ERROR] LCM not found while building lcmtypes, cmake will exit.")
endif()
